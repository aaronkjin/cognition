# Dependency Vulnerability Remediation

## Overview
Upgrade a vulnerable dependency to the patched version, resolve any breaking changes introduced by the upgrade, verify the fix with tests, and open a pull request referencing the CVE/CWE.

## What's Needed From User
The session prompt will include:
- `finding_id` — unique identifier for this finding (e.g., FIND-0001)
- `dependency_name` — the vulnerable package (e.g., `log4j-core`, `requests`, `lodash`)
- `current_version` — the currently installed vulnerable version
- `fixed_version` — the minimum version that contains the fix
- `language` — Java, Python, TypeScript, or Go
- `file_path` — path to the manifest file (pom.xml, requirements.txt, package.json, go.mod)
- `repo_url` — the repository URL to clone
- `cwe_id` — the CWE identifier (e.g., CWE-502)
- `title` — short description of the vulnerability
- `description` — detailed description of the vulnerability

## Procedure
1. Clone the repository from `repo_url` if not already present.
2. Read the finding details from the session prompt: `dependency_name`, `current_version`, `fixed_version`, `language`, `file_path`, `cwe_id`.
3. Update structured output: status="analyzing", progress_pct=10, current_step="Reading finding details".
4. Open the manifest file at `file_path` and locate the dependency entry for `dependency_name`.
5. Determine the package manager:
   - Java: Maven (`pom.xml`) or Gradle (`build.gradle` / `build.gradle.kts`)
   - Python: pip (`requirements.txt`, `setup.py`, `pyproject.toml`) or Poetry (`pyproject.toml` with `[tool.poetry]`)
   - TypeScript/JavaScript: npm (`package.json`) or yarn (`package.json` + `yarn.lock`)
   - Go: Go modules (`go.mod`)
6. Check the dependency's changelog or release notes for breaking changes between `current_version` and `fixed_version`. Look for migration guides if this is a major version bump.
7. Update structured output: status="analyzing", progress_pct=20, fix_approach=<your upgrade plan including any breaking changes found>, confidence=<your assessment>.
8. Create a new branch named `fix/FIND-{finding_id}-{dependency_name}` from the default branch.
9. Update the dependency version in the manifest file from `current_version` to `fixed_version`.
10. Run the package manager's install/resolve command to update the lock file:
    - Maven: `mvn dependency:resolve`
    - pip: `pip install -r requirements.txt` (or equivalent)
    - npm: `npm install`
    - Go: `go mod tidy`
11. For Maven, run `mvn dependency:tree` to check for transitive dependency conflicts. For npm, check for peer dependency warnings in the install output. For pip, check for version conflicts. For Go, check `go mod tidy` output.
12. Update structured output: status="fixing", progress_pct=40, files_modified=<list of files changed so far>.
13. If there are breaking API changes between `current_version` and `fixed_version`:
    a. Search the codebase for usages of the changed APIs using grep or the IDE.
    b. Update each usage site to be compatible with `fixed_version`.
    c. Add each modified file to the `files_modified` list.
14. Update structured output: status="fixing", progress_pct=50, files_modified=<updated list>.
15. Run the existing test suite:
    - Maven: `mvn test`
    - Python: `pytest` or `python -m pytest`
    - npm: `npm test`
    - Go: `go test ./...`
16. Update structured output: status="testing", progress_pct=70.
17. If tests fail due to the upgrade:
    a. Read the failure output carefully.
    b. Fix the failing tests by updating them for the new dependency version.
    c. Re-run the test suite to confirm all tests pass.
18. Update structured output: status="testing", progress_pct=75, tests_passed=<true/false>, tests_added=<count of any new tests>.
19. Commit all changes with a descriptive message: `fix: upgrade {dependency_name} from {current_version} to {fixed_version} [{finding_id}]`.
20. Push the branch to the remote.
21. Update structured output: status="creating_pr", progress_pct=90.
22. Create a pull request with:
    - Title: `fix: upgrade {dependency_name} from {current_version} to {fixed_version} [{finding_id}]`
    - Body that includes:
      - Reference to the CVE/CWE (`cwe_id`)
      - What vulnerability this fixes
      - What version change was made
      - Any breaking changes addressed
      - List of files modified
      - Test results
23. Update structured output: status="completed", progress_pct=100, pr_url=<the PR URL>.

## Specifications
When the task is complete, ALL of the following must be true:
- The dependency version in the manifest file is updated to at least `fixed_version`.
- The lock file (if applicable) is updated and consistent.
- All existing tests pass.
- Any breaking API changes from the upgrade are resolved in the codebase.
- A pull request exists on a feature branch (not main/master) with a clear title and body referencing the finding ID and CVE/CWE.
- Structured output reflects status="completed" with progress_pct=100.

## Structured Output Updates
Update the structured output JSON after each major step using this schema:
```json
{
  "finding_id": "<string>",
  "status": "analyzing | fixing | testing | creating_pr | completed | failed",
  "progress_pct": "<integer 0-100>",
  "current_step": "<string>",
  "fix_approach": "<string or null>",
  "files_modified": ["<array of strings>"],
  "tests_passed": "<boolean or null>",
  "tests_added": "<integer>",
  "pr_url": "<string or null>",
  "error_message": "<string or null>",
  "confidence": "high | medium | low"
}
```

Update at these checkpoints:
- After reading finding details: status="analyzing", progress_pct=10
- After analyzing changelog/breaking changes: status="analyzing", progress_pct=20, fix_approach=<plan>, confidence=<assessment>
- After updating dependency version: status="fixing", progress_pct=40, files_modified=<list>
- After resolving breaking changes: status="fixing", progress_pct=50, files_modified=<updated list>
- After running tests: status="testing", progress_pct=75, tests_passed=<bool>, tests_added=<count>
- After creating PR: status="creating_pr", progress_pct=90, pr_url=<url>
- On completion: status="completed", progress_pct=100
- On failure at any step: status="failed", error_message=<what went wrong>

## Advice and Pointers
- For major version bumps (e.g., 1.x → 2.x), always check the migration guide before making changes. Major bumps are more likely to have breaking changes.
- For Java/Maven, run `mvn dependency:tree` to check for transitive dependency conflicts. A transitive dependency may pull in an incompatible version of another library.
- For Python, check for version conflicts with other packages in the requirements file. Use `pip check` after installing to verify dependency consistency.
- For npm, check for peer dependency warnings during install. Peer dependency conflicts can cause runtime errors even if install succeeds.
- For Go, `go mod tidy` will clean up unused dependencies and resolve version conflicts automatically.
- If the fixed version introduces deprecation warnings (but not errors), note them in the PR body but do not fix them — that is out of scope.
- If the changelog is unavailable, compare API surfaces by reading the library's source or documentation at both versions.
- When in doubt about the scope of breaking changes, set confidence to "medium" or "low" and note the uncertainty in the PR body.

## Forbidden Actions
- Do not commit directly to main or master branch. Always create a new feature branch.
- Do not disable, skip, or delete existing tests.
- Do not modify unrelated business logic.
- Do not introduce new dependencies without strong justification.
- Do not remove or weaken existing security controls.
- Do not downgrade other dependencies to resolve conflicts unless absolutely necessary, and document the reason.
- Do not pin the dependency to an exact version if the project uses range specifiers — match the existing versioning style.
